# Git学习笔记

> 作者：张子宇（由 Gemini 2.5 Pro撰写）

### **为什么我们要用 Git？**

告别手动拷贝压缩包的混乱时代！Git 带给我们：

*   **云端备份**：你的代码安全地存储在 GitHub 上，电脑坏了也不怕。
*   **版本控制**：代码改错了？一键回到昨天、上周甚至去年的任何一个版本。
*   **高效协作**：多人开发互不干扰，安全合并各自的工作成果。
*   **清晰记录**：谁在何时修改了什么，一目了然，不再有“这是谁改的代码？”的疑问。

### **第一部分：【仅需一次】的终极配置**

#### **1. 配置 SSH 密钥 (一劳永逸，告别密码)**

SSH 密钥就像是你电脑的一把专属“钥匙”，只要把它配对到 GitHub，以后你的电脑和 GitHub 之间所有的操作都会被自动授权，**再也无需输入用户名和密码**。

1.  **生成 SSH 密钥**
    打开终端，粘贴以下命令并回车。遇到提示时，**连续按三次 Enter 键**即可（不需要设置密码）。记得将邮箱修改为你注册Github的邮箱。
    ```bash
    ssh-keygen -t ed25519 -C "your_email@example.com"
    ```

2.  **复制你的公钥**
    公钥就是你要交给 GitHub 的那把“钥匙”。运行以下命令，它会把钥匙内容显示在终端里，然后**完整地复制**这些内容。
    ```bash
    cat ~/.ssh/id_ed25519.pub
    ```
    (它看起来像 `ssh-ed25519 AAAAC3... your_email@example.com`)

3.  **添加到 GitHub**
    *   登录 GitHub，点击右上角头像 -> `Settings`。
    *   在左侧菜单栏找到 `SSH and GPG keys`。
    *   点击 `New SSH key` 按钮。
    *   `Title` 可以随便写一个，比如 "My Ubuntu Workstation"。
    *   在 `Key` 文本框里，**粘贴**你刚刚复制的公钥内容。
    *   点击 `Add SSH key`。完成！

#### **2. 设置 Git 身份**

```bash
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
```

---

### **第二部分：【项目组长】创建与上传第一个项目**

1.  **进入项目文件夹并初始化**
    ```bash
    cd ~/my_ros_ws
    git init
    ```

2.  **创建 `.gitignore` 文件 (ROS 关键步骤)**
    ```bash
    gedit .gitignore
    ```
    复制以下内容并保存，告诉 Git 忽略编译文件。
    ```gitignore
    build/
    devel/
    install/
    *.log
    log/
    .catkin_tools/
    catkin_generated/
    CATKIN_IGNORE
    *.swp
    *~
    ```

3.  **进行第一次提交 (Commit)**
    ```bash
    git add .
    git commit -m "Initial commit of my_ros_ws project"
    ```

4.  **在 GitHub 创建空仓库**
    *   `New repository` -> 填写仓库名 -> **不要勾选任何初始化选项** -> `Create repository`。

5.  **关联并推送 (使用 SSH 地址)**
    *   在 GitHub 新仓库页面，确保你选择的是 **SSH** 模式，然后复制地址。
    ```bash
    # 关联远程仓库
    git remote add origin git@github.com:YourUsername/my_ros_ws.git

    # 推送代码
    git push -u origin main
    ```

---

### **第三部分：个人开发的核心：备份与回滚**

这部分主要针对独立负责项目或功能模块的开发者。**你的核心工作流就是不断地创建安全的存档点（commit），并备份到云端（push）。**

#### **日常工作流：编码 -> 存档 -> 备份**

1.  **开始工作前，先与云端同步**
    ```bash
    cd ~/my_ros_ws
    git pull
    ```

2.  **完成一个功能点后，创建存档点**
    这个“存档点”就是 `commit`。**频繁地、小步地提交是一个好习惯。**
    ```bash
    # 1. 查看修改了哪些文件
    git status

    # 2. 将所有修改加入待存档列表
    git add .

    # 3. 创建存档，并写清楚本次存档的内容
    git commit -m "Feat: Implement lidar data filter"
    ```

3.  **将存档备份到云端**
    一天工作结束时，或者完成一个重要阶段后，一定要 `push`！
    ```bash
    git push
    ```
    **`git push` 就是你最简单、最有效的云端备份方式！**

#### **你的安全网：如何“撤销”各种错误**

##### **场景 1：“这个文件我改乱了，想恢复到上次存档的样子。”**

> **命令：`git restore <文件名>`**

这是最常用、最安全的“撤销”操作，它只会影响你指定的文件。

```bash
# 假设你不小心改坏了 a.cpp
git restore src/package/src/a.cpp
```
执行后，`a.cpp` 就会瞬间变回你上次 `commit` 时的状态。

##### **场景 2：“我刚提交(commit)了，但还没推送(push)，发现提交说明写错了/漏了文件。”**

> **命令：`git reset --soft HEAD~1`**

这个命令会**撤销掉你最后一次的 `commit`**，但**会保留你修改的所有代码**。

1.  **撤销上一次提交**
    ```bash
    git reset --soft HEAD~1
    ```
2.  **重新提交**
    现在你可以重新 `git add .` （如果之前有漏掉的文件），然后用正确的说明 `git commit -m "..."` 再次提交。

##### **场景 3：“我刚提交(commit)了，但还没推送(push)，发现这次提交完全是错误的，代码和提交都不要了！”**

> **警告：危险操作，会丢弃代码！**
> **命令：`git reset --hard HEAD~1`**

这个命令会彻底地、永久地删除你最后一次的 `commit` 以及对应的所有代码修改。

##### **场景 4：“我推送(push)了一个错误到云端，需要撤销它。”**

> **命令：`git revert HEAD`**

这是**最安全、最推荐**的撤销已推送内容的方式。它不会删除历史，而是**创建一个新的“反向”提交**来抵消那个错误的提交。

1.  **创建一个“撤销”提交**
    ```bash
    git revert HEAD
    ```
    会弹出一个编辑器让你确认提交信息，直接保存退出即可。
2.  **将这个“撤销”操作推送到云端**
    ```bash
    git push
    ```
    现在，云端的错误就被安全地修正了，并且保留了所有操作记录。

##### **场景 5：“我只想回到过去看看某个旧版本的代码，看完就回来。”**

> **命令：`git checkout <commit_id>`**

1.  **找到你想去的历史版本ID**
    ```bash
    git log --oneline
    ```
    (会列出所有历史提交，前面那串黄色的字符就是 commit_id)

2.  **开始“时间旅行”**
    ```bash
    # 只需要复制ID的前7位左右即可
    git checkout a1b8c3d
    ```
    现在你的整个项目文件都变成了那个旧版本的样子。你可以随便看、编译、测试。

3.  **返回现在**
    ```bash
    git checkout main  # 或者你的主分支名
    ```

---

### **第四部分：团队协作的核心：分支**

当你进行团队协作时，只需要每个人将仓库`clone`后，随时`pull`和`push`即可。但是，要开发一个复杂的新功能时，直接在主分支 (`main`) 上修改很危险，可能会把代码改崩，影响其他同事。**分支**可以解决这个问题。

分支就像是当前项目的一个“平行宇宙”或“副本”，你可以在里面随便修改，不会影响主线。

#### **分支工作流**

1.  **创建并切换到新分支**：假设你要开发一个“路径规划”功能。
    ```bash
    # 确保你当前在最新的主分支上
    git pull

    # 创建一个叫 feature/path-planning 的分支，并立即切换过去
    git checkout -b feature/path-planning
    ```

2.  **在新分支上尽情工作**：现在，你可以像平常一样，不断地 `add`, `commit`, `push`。
    ```bash
    # ...修改代码...
    git add .
    git commit -m "Feat: Implement A* algorithm core"
    
    # 第一次推送新分支时，需要用 -u 建立跟踪
    git push -u origin feature/path-planning
    ```
    你在新分支上的所有操作，都不会影响到 `main` 分支。其他同事 `git pull` 时，也看不到你的这些修改。

3.  **完成功能，发起合并请求 (Pull Request)**
    当你的功能开发完成并通过测试后：
    *   **去 GitHub 网站**，你会看到一个黄色的提示条，让你为你刚推送的分支创建一个 "Pull Request"。
    *   点击它，写下你的功能说明，然后创建 Pull Request (简称 PR)。
    *   **PR 的作用是**：请求项目组长或其他同事**评审 (Review)** 你的代码。确认没问题后，由他们在 GitHub 页面上点击 "Merge" 按钮，将你的功能分支安全地合并到主分支 `main` 中。

4.  **合并后清理**：
    *   大家再次 `git pull`，就能获取到包含你新功能的最新代码了。
    *   你可以切换回主分支，并删除已经无用的本地分支。
    ```bash
    git checkout main
    git pull
    git branch -d feature/path-planning
    ```


---

### **命令小抄（更新版）**

| 命令 | 作用 |
| :--- | :--- |
| `git clone <ssh_url>` | 【仅一次】从云端下载整个项目 |
| `git pull` | 从云端拉取最新代码并与本地合并 |
| `git push` | **【云端备份】** 将本地的提交推送到云端 |
| `git status` | 查看当前仓库状态，**最常用！** |
| `git add .` | 将所有修改过的文件加入待提交列表 |
| `git commit -m "说明"` | 创建一个本地存档点 |
| `git checkout -b <分支名>` | 创建并切换到一个新分支 |
| `git log --oneline` | 简洁地查看提交历史 |
| `git restore <文件名>` | **【撤销修改】** 放弃对某个文件的修改 |
| `git reset --soft HEAD~1`| **【修改提交】** 撤销上次提交，但保留代码 |
| `git revert HEAD` | **【修正云端】** 创建一个反向提交来撤销已推送的错误 |

### **核心原理解析：你的代码到底去了哪里？**

要真正理解 Git，你需要知道它有**四个工作区域**。我们可以用一个**“快递打包”**的生动比喻来理解。

1.  **工作区 (Working Directory)**
    *   **是什么**：就是你在电脑上能看到的项目文件夹，你可以直接用 VS Code 或其他编辑器修改里面的文件。
    *   **快递比喻**：你的**工作台**。你正在这里制作、修改你的产品（代码）。

2.  **暂存区 (Staging Area)**
    *   **是什么**：一个看不见的、临时的区域，用于存放你“打算”在下一次提交中包含的修改。
    *   **快递比喻**：一个**快递箱**。你从工作台上挑选出已经完成修改的产品，**放进**这个箱子里，准备打包。
    *   **对应命令**：`git add .` 就是一个动作，意思是“把我工作台上**所有**修改过的东西，都放进这个快递箱里”。

3.  **本地仓库 (Local Repository)**
    *   **是什么**：存放在你电脑 `.git` 文件夹里的一个完整的版本历史数据库。它包含了你项目的所有“快照”（提交）。这是你**自己的、私有的**历史记录。
    *   **快递比喻**：仓库的**“待发货区”**。快递箱里的东西确认无误后，你用胶带**封上箱子**，并在上面**贴一张标签**（写清楚里面是什么），然后把它放到待发货区。这个区域可以存放很多已经打包好的箱子。
    *   **对应命令**：`git commit -m "..."` 就是“封箱贴标签”这个动作。它把暂存区（快递箱）里的所有内容，打包成一个永久的快照（一个贴好标签的包裹），存放到你的本地仓库（待发货区）。

4.  **远程仓库 (Remote Repository)**
    *   **是什么**：存放在云端服务器（如 GitHub）上的仓库，是团队共享版本历史的地方。
    *   **快递比喻**：远方的**中央总仓**。
    *   **对应命令**：`git push` 就是一个动作，意思是“叫一辆卡车，把‘待发货区’里**所有**打包好的新包裹，一次性全部运到中央总仓去”，让所有人都能看到。

**总结：**
`add` 是把代码从 **工作区** -> **暂存区**。
`commit` 是把代码从 **暂存区** -> **本地仓库**。
`push` 是把代码从 **本地仓库** -> **远程仓库**。

理解了这个流程，你就不会再对这些命令感到困惑了！